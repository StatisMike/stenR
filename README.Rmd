---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
Sys.setenv(LANGUAGE='en')
```

# stenR

<!-- badges: start -->
[![Codecov test coverage](https://codecov.io/gh/StatisMike/stenR/branch/master/graph/badge.svg)](https://codecov.io/gh/StatisMike/stenR?branch=master)
[![Lifecycle: stable](https://img.shields.io/badge/lifecycle-stable-brightgreen.svg)](https://www.tidyverse.org/lifecycle/#stable)
[![Codecov test coverage](https://codecov.io/gh/StatisMike/stenR/branch/master/graph/badge.svg)](https://app.codecov.io/gh/StatisMike/stenR?branch=master)
[![R-CMD-check](https://github.com/StatisMike/stenR/workflows/R-CMD-check/badge.svg)](https://github.com/StatisMike/stenR/actions)
<!-- badges: end -->

`stenR` is a package tailored mainly for creators of psychological questionnaires,
though other social science researchers and survey authors can benefit greatly
from it.

It normalizes and standardizes results to standard scale of your choosing. It
works on basis of source data: creates frequency table and computes Z score
corresponding to particular raw score. After that you can get the score for
all observations in the sourced data, chosen individuals or external data not
used for calculating the norms.

## Installation

You can install the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("StatisMike/stenR")
```
## Recommended workflow for using stenR functionality

`stenR` currently is based entirely on one `R6 class`: computed frequency table,
or `CompFreqtable`. This document will shortly document the available
methods and functions.

### Creating `CompFreqtable`

Firstly you need to initialize new computed frequency table. It is recommended
to do it using `gen_freqtable()` function.

```{r initialize object}
library(stenR)

# We will use data provided in the package

freqtable <- gen_freqtable(
  data = HEXACO_60,
  vars = c("HEX_H", "HEX_E", "HEX_X", "HEX_A", "HEX_C", "HEX_O"),
  id = "user_id"
)
```
After initialization of the object, you can get some warnings. They indicate 
that there are some values of raw score that weren't represented in the data. 
By the rule of thumb: the more possible values the raw scores can get and the 
smaller your data, the bigger possibility for it to happen. If you feel that 
your sample was representative, you can ignore it. It is recommended though to 
get more varied, greater number of observations when getting this warning - or 
clean your data more thoroughly.

### Computing scores in standard scale

After creation of your `CompFreqtable` object, you then need to calculate scores
in scoring scale of your choice (or multiple of them). You can do it with `compute_scores(scale)` method:

```{r compute_scores method}
# one of most commonly used scales is a STEN scale
freqtable$compute_scores("sten")
# though we can also use tanines
freqtable$compute_scores("tanine")
```

Now `freqtable` object holds scores computed in both *STEN* and *tanine* scales.
We can check the state using `get_status()` method. It returns a list object,
and `standardized scores` character vector holds the names of computed
scores.

```{r get_status method}
freqtable$get_status()$standardized_scores
```

You can also get complete summary on current state of your object in 
a human-readable way with `summary()`

```{r summary_method}
summary(freqtable)
```

### Getting computed scores for observations

When results are available, you can get them using `get_computed_scores()` method:

```{r get_computed_scores all}
# we will print only few first rows of results
head(
  freqtable$get_computed_scores("sten")
  )
```
You can also get only scores for specific observations and variables:

```{r get_computed_scores_individual}
freqtable$get_computed_scores(
  "tanine",
  vars = c("HEX_H", "HEX_C"),
  ids = c("decrepit_norwayrat", "trapeziform_zebradove")
)
```
If you need to get scores for some other observations, not present in the source data, 
you can get it with use of `get_computed_scores_ext()` method:

```{r get_computed_scores_ext()}
external_data <- data.frame(
  # names of the variables don't need to be the same as in computed freqtable
  Extraversion = c(25, 42),
  # and can also be supplied as characters. Just make sure it can be coerced to numerical
  Openness = c("40", "23")
)

freqtable$get_computed_scores_ext(
  data = external_data,
  scale = "tanine",
    # if the names are different, you need to provide named character vector
  vars = c(HEX_X = "Extraversion", HEX_O = "Openness")
)
```

## Available methods and their functionality

Besides the basic methods shared by all `R6 class` objects, 
`CompFreqtable` supports currently following methods:

- `get_status()` - returns list with details of current status of the object,
- `get_data_info()` - returns list with information of the basic source data structure,
- `get_freqtables()` - returns frequency tables for each variable
- `compute_scores()` - compute score in one of the built-in standard scales or a custom one. Currently, there are built-in definitions of following:
  - *sten* (M = 5.5, SD = 2, min = 1, max = 10),
  - *stanine* (M = 5, SD = 2, min = 1, max = 9),
  - *tanine* (M = 50, SD = 10, min = 1, max = 100),
  - *tetronic* (M = 10, SD = 4, min = 0, max = 20),
  - *wechsler-iq* (M = 100, SD = 15, min = 40, max = 160)
- `get_scoretables()` - returns scoring tables in specified computed scale,
- `get_computed_scores()` - returns scores of source data for specified computed scale,
- `get_computed_scores_ext()` - returns scores of external data for specified computed scale.


